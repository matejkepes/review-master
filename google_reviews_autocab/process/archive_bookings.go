package process

import (
	"encoding/json"
	"log"
	"math/rand"
	"net/url"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/dongri/phonenumber"

	"google_reviews_autocab/autocab_api"
	"google_reviews_autocab/autocab_api_v1"
	"google_reviews_autocab/autocab_api_v2"
	"google_reviews_autocab/barred"
	"google_reviews_autocab/client"
	"google_reviews_autocab/config"
	"google_reviews_autocab/database"
	"google_reviews_autocab/utils"
)

// global mutex to prevent code which sends SMS running in parallel because the SMS gateway
// is unable to handle the number of requests generated by this code at once.
var sendSmsMutex sync.Mutex

var Bars []string

// PollAutocab - poll Autocab
//
//	func PollAutocab(db *sql.DB, config config.Config, lastPollTime, startPollTime time.Time) {
//		// get the Autocab configs
//		grcftwcs := database.GetAutocabConfigsWithChecks(db, false)
//		// WaitGroup used to synchronise goroutines so can wait for all to be complete
//		var wg sync.WaitGroup
//		// iterate over configs
//		for _, grcftwc := range grcftwcs {
//			// get autorisation token
//			authorisationToken := autocab_api.GetAuthorisationTokenFromServer(grcftwc.DispatcherURL, grcftwc.AppKey, grcftwc.SecretKey)
//			if authorisationToken == "" {
//				log.Printf("Error getting Autocab authorisation token for ClientID %d\n", grcftwc.ClientID)
//				continue
//			}
//			// get archived bookings
//			archiveBookings := autocab_api.GetArchiveBookingsFromServer(grcftwc.DispatcherURL, authorisationToken, lastPollTime, startPollTime)
//			for _, archiveBooking := range archiveBookings {
//				// log.Printf("archiveBooking: %+v\n", archiveBooking)
//				// NOTE: processing in goroutines causes issues with what is in the database so not done.
//				// // increment the WaitGroup counter
//				// wg.Add(1)
//				// // run in goroutine
//				// go processArchiveBooking(db, config, archiveBooking, grcftwc, &wg)
//				processArchiveBooking(db, config, archiveBooking, grcftwc)
//			}
//		}
//		// wait fro all goroutines to complete
//		wg.Wait()
//	}
func PollAutocab(lastPollTime, startPollTime time.Time) {
	// get the Autocab configs
	grcftwcs := database.GetAutocabConfigsWithChecks(false)
	// WaitGroup used to synchronise goroutines so can wait for all to be complete
	var wg sync.WaitGroup
	// iterate over configs
	for _, grcftwc := range grcftwcs {
		// increment the WaitGroup counter
		wg.Add(1)
		// run in goroutine
		go processConfig(lastPollTime, startPollTime, grcftwc, &wg)
	}
	// wait fro all goroutines to complete
	wg.Wait()
}

// // processConfig - process each google config
// func processConfig(db *sql.DB, config config.Config, lastPollTime, startPollTime time.Time, grcftwc database.GoogleReviewsConfigFromTokenWithChecks, wg *sync.WaitGroup) {
// 	// decrement the counter when goroutine completes
// 	defer wg.Done()
// 	// get autorisation token
// 	authorisationToken := autocab_api.GetAuthorisationTokenFromServer(grcftwc.DispatcherURL, grcftwc.AppKey, grcftwc.SecretKey)
// 	if authorisationToken == "" {
// 		log.Printf("Error getting Autocab authorisation token for ClientID: %d\n", grcftwc.ClientID)
// 		return
// 	}
// 	// times need to be converted to the Autocab local server time
// 	lastPoll := utils.ConvertToTimeZone(lastPollTime, grcftwc.TimeZone)
// 	startPoll := utils.ConvertToTimeZone(startPollTime, grcftwc.TimeZone)
// 	// get archived bookings
// 	// archiveBookings := autocab_api.GetArchiveBookingsFromServer(grcftwc.DispatcherURL, authorisationToken, lastPollTime, startPollTime)
// 	archiveBookings := autocab_api.GetArchiveBookingsFromServer(grcftwc.DispatcherURL, authorisationToken, lastPoll, startPoll)
// 	// check whether sent daily allowance
// 	sentCount := database.DailySentCount(db, grcftwc.ClientID)
// 	for _, archiveBooking := range archiveBookings {
// 		// log.Printf("archiveBooking: %+v\n", archiveBooking)
// 		sent := processArchiveBooking(db, config, archiveBooking, grcftwc)
// 		if sent {
// 			sentCount += 1
// 			if sentCount > grcftwc.MaxDailySendCount {
// 				// log.Printf("Autocab config has reached maximum daily send count of %d for clientID: %d", maxDailySendCount, clientID)
// 				break
// 			}
// 		}
// 	}
// }

// processConfig - process each google config
func processConfig(lastPollTime, startPollTime time.Time, grcftwc database.GoogleReviewsConfigFromTokenWithChecks, wg *sync.WaitGroup) {
	// decrement the counter when goroutine completes
	defer wg.Done()
	authorisationToken := ""
	if grcftwc.DispatcherType == "AUTOCAB" {
		// get autorisation token
		authorisationToken = autocab_api.GetAuthorisationTokenFromServer(grcftwc.DispatcherURL, grcftwc.AppKey, grcftwc.SecretKey)
		if authorisationToken == "" {
			log.Printf("Error getting Autocab authorisation token for ClientID: %d\n", grcftwc.ClientID)
			return
		}
	}
	// times need to be converted to the Autocab local server time
	lastPoll := utils.ConvertToTimeZone(lastPollTime, grcftwc.TimeZone)
	startPoll := utils.ConvertToTimeZone(startPollTime, grcftwc.TimeZone)
	// get archived bookings
	var archiveBookings []autocab_api.ArchiveBooking
	if grcftwc.DispatcherType == "AUTOCAB" {
		archiveBookings = autocab_api.GetArchiveBookingsFromServer(grcftwc.DispatcherURL, authorisationToken, lastPoll, startPoll)
	} else if grcftwc.DispatcherType == "AUTOCAB_V1" {
		bookings := autocab_api_v1.GetBookingsFromServer(grcftwc.DispatcherURL, grcftwc.AppKey, lastPoll, startPoll)
		archiveBookings = autocab_api_v1.TranslateBookingsToArchiveBookings(bookings)
	} else if grcftwc.DispatcherType == "AUTOCAB_V2" {
		bookings := autocab_api_v2.GetBookingsFromServer(grcftwc.DispatcherURL, grcftwc.AppKey, lastPoll, startPoll)
		archiveBookings = autocab_api_v2.TranslateBookingsToArchiveBookings(bookings)
	}
	// check whether sent daily allowance
	sentCount := database.DailySentCount(grcftwc.ClientID)
	var sendLaterCount uint
	numberSent := 0
	for _, archiveBooking := range archiveBookings {
		// log.Printf("archiveBooking: %+v\n", archiveBooking)
		sent, sendLater := processArchiveBooking(archiveBooking, grcftwc)
		if sent || sendLater {
			if sent {
				sentCount += 1
				numberSent += 1
			}
			if sendLater {
				sendLaterCount += 1
			}
			if (sentCount + sendLaterCount) > grcftwc.MaxDailySendCount {
				// log.Printf("Autocab config has reached maximum daily send count of %d for clientID: %d", maxDailySendCount, clientID)
				break
			}
		}
	}
	// update stats (ignore send later, as these are counted when sent later)
	database.UpdateStatsWithCounts(grcftwc.ClientID, numberSent, len(archiveBookings))
}

// NOTE: processing in goroutines causes issues with what is in the database so not done.
// processArchiveBooking - process each archive booking
// func processArchiveBooking(db *sql.DB, config config.Config, archiveBooking autocab_api.ArchiveBooking, grcftwc database.GoogleReviewsConfigFromTokenWithChecks, wg *sync.WaitGroup) {
// 	// decrement the counter when goroutine completes
// 	defer wg.Done()
// 	// check whether to send SMS
// 	sendSMS, telephone, message, sentCount := CheckBooking(db, archiveBooking, grcftwc)
// 	log.Printf("sendSMS: %t, telephone: %s, message: %s\n", sendSMS, telephone, message)
// 	if sendSMS {
// 		// TODO: send SMS code request to Autocab
// 		// send SMS to own server
// 		params := url.Values{}
// 		params.Add(config.SendSmsTokenParameter, config.SendSmsToken)
// 		params.Add(config.SendSmsTelephoneParameter, telephone)
// 		params.Add(config.SendSmsMessageParameter, message)
// 		resp := client.Send(config.SendSmsURL, "POST", nil, params)
// 		fmt.Println("resp: ", resp)
// 		if resp != config.SendSmsSuccessResponse {
// 			log.Printf("Error sending SMS message for telephone: %s, message: %s\n", telephone, message)
// 			return
// 		}
// 		// update last sent in database
// 		database.UpdateLastSent(db, telephone, grcftwc.ClientID, sentCount+1)
// 	}
// }

// // processArchiveBooking - process each archive booking
// // return true to indicate that a booking has been sent a message else false
// func processArchiveBooking(db *sql.DB, config config.Config, archiveBooking autocab_api.ArchiveBooking, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) bool {
// 	// check whether to send SMS
// 	sendSMS, telephone, telephoneSendSMS, message, sentCount := CheckBooking(db, archiveBooking, grcftwc)
// 	log.Printf("sendSMS: %t, telephone: %s, message: %s\n", sendSMS, telephone, message)
// 	if sendSMS {
// 		// TODO: send SMS code request to Autocab
// 		// send SMS to own server
// 		params := url.Values{}
// 		params.Add(config.SendSmsTokenParameter, config.SendSmsToken)
// 		params.Add(config.SendSmsTelephoneParameter, telephoneSendSMS)
// 		params.Add(config.SendSmsMessageParameter, message)
// 		resp := client.Send(config.SendSmsURL, "POST", nil, params, nil)
// 		log.Println("resp: ", resp)

// 		if resp != config.SendSmsSuccessResponse {
// 			log.Printf("Error sending SMS message for telephone: %s, message: %s\n", telephone, message)
// 			return false
// 		}
// 		// update last sent in database
// 		database.UpdateLastSent(db, telephone, grcftwc.ClientID, sentCount+1)
// 		return true
// 	}
// 	return false
// }

// processArchiveBooking - process each archive booking
// return two booleans:
//   - first indicates if the booking has been sent a message (true) else false
//   - second indicates if the booking will be sent a message later (true) else false
func processArchiveBooking(archiveBooking autocab_api.ArchiveBooking, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) (bool, bool) {
	// check whether to send SMS
	sendSMS, telephone, telephoneSendSMS, message, sentCount := CheckBooking(archiveBooking, grcftwc)
	log.Printf("sendSMS: %t, telephone: %s, message: %s\n", sendSMS, telephone, message)
	var resp string
	if sendSMS {
		if grcftwc.SendDelayEnabled && grcftwc.SendDelay > 0 {
			// send later
			var params url.Values
			var body []byte
			var headers map[string]string
			sendMessageURL := config.Conf.SendSmsURL
			sendFromOwnSMSGateway := false
			alternateMessageServiceEnabled := false
			alternateMessageService := ""
			if grcftwc.ReviewMasterSMSGatewayEnabled {
				// send to Review Master SMS Gateway
				sendMessageURL = config.Conf.ReviewMasterSMSGatewayURL
				params = nil
				reviewMasterSMSGatewayQueueID := grcftwc.ClientID
				if grcftwc.ReviewMasterSMSGatewayUseMasterQueue {
					reviewMasterSMSGatewayQueueID = uint64(database.ReviewMasterSMSMasterQueue)
				}
				body, _ = json.Marshal(map[string]string{
					"queue_id":  strconv.FormatUint(reviewMasterSMSGatewayQueueID, 10),
					"telephone": "+" + telephone,
					"message":   message,
				})
				headers = map[string]string{
					"Content-Type": "application/json",
					"Accept":       "application/json",
					"Api-Token":    config.Conf.ReviewMasterSMSGatewayApiToken,
				}
			} else if grcftwc.AlternateMessageServiceEnabled && grcftwc.AlternateMessageService == "AUTOCAB_V1" {
				// send to Autocab V1 Send SMS API
				alternateMessageServiceEnabled = true
				alternateMessageService = grcftwc.AlternateMessageService

				apiURL := grcftwc.SendURL
				if !strings.HasSuffix(apiURL, "/") {
					apiURL += "/"
				}
				apiURL += "sms/v1/send"
				sendMessageURL = apiURL

				params = nil

				key := strings.TrimSpace(grcftwc.AlternateMessageServiceSecret1)

				headers = map[string]string{
					"Content-Type":              "application/json",
					"Accept":                    "application/json",
					"Ocp-Apim-Subscription-Key": key,
				}

				body, _ = json.Marshal(autocab_api_v1.SendSMSRequest{
					SenderName:      config.Conf.AutocabSendSMSSenderName,
					RecipientTelnos: []string{telephone},
					Message:         message,
				})
			} else {
				// send SMS to own server
				sendFromOwnSMSGateway = true
				params.Add(config.Conf.SendSmsTokenParameter, config.Conf.SendSmsToken)
				params.Add(config.Conf.SendSmsTelephoneParameter, telephone)
				params.Add(config.Conf.SendSmsMessageParameter, message)
				body = nil
				headers = nil
			}
			// store request in database
			database.AddSendLater(telephone, grcftwc.ClientID, int(grcftwc.SendDelay),
				sendMessageURL, "POST", "", "",
				headers, params, body, false,
				grcftwc.ReviewMasterSMSGatewayEnabled,
				alternateMessageServiceEnabled, alternateMessageService,
				sendFromOwnSMSGateway, grcftwc.SendSuccessResponse, grcftwc.MaxDailySendCount)
			return false, true
		} else {
			// send now
			var expectedSuccessResponse string
			// TODO: send SMS code request to Autocab
			if grcftwc.ReviewMasterSMSGatewayEnabled {
				// send to Review Master SMS Gateway
				expectedSuccessResponse = grcftwc.SendSuccessResponse
				resp = SendReviewMasterSMSGateway(telephoneSendSMS, message, grcftwc)
			} else if grcftwc.AlternateMessageServiceEnabled && grcftwc.AlternateMessageService == "AUTOCAB_V1" {
				// send to Autocab V1 Send SMS API
				expectedSuccessResponse = grcftwc.SendSuccessResponse
				success := autocab_api_v1.SendSMS(strings.TrimSpace(grcftwc.SendURL), strings.TrimSpace(grcftwc.AlternateMessageServiceSecret1),
					telephone, message, config.Conf.AutocabSendSMSSenderName)
				if success {
					resp = grcftwc.SendSuccessResponse
				}
			} else {
				// send SMS to own server
				expectedSuccessResponse = config.Conf.SendSmsSuccessResponse
				resp = SendSMSServer(telephoneSendSMS, message, grcftwc)
			}
			log.Printf("send sms for telephone: %s resp: %s\n", telephoneSendSMS, resp)

			if resp != expectedSuccessResponse {
				log.Printf("Error sending SMS message, got response '%s' expected '%s' for telephone: %s, message: %s\n", resp, expectedSuccessResponse, telephone, message)
				return false, false
			}
			// update last sent in database
			database.UpdateLastSent(telephone, grcftwc.ClientID, sentCount+1)
			return true, false
		}
	}
	return false, false
}

// CheckBooking - check booking returning whether successful and telephone number and message to send via SMS and the sent count
func CheckBooking(archiveBooking autocab_api.ArchiveBooking, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) (bool, string, string, string, uint) {
	tel := archiveBooking.TelephoneNumber
	// log.Printf("t param: %s\n", tel)
	// telephone := phonenumber.Parse(tel, grcftwc.Country)
	telephone := utils.TelephoneParse(tel, grcftwc.Country)
	// log.Printf("telephone: %s\n", telephone)
	if telephone == "" {
		log.Printf("no telephone found (sent telephone parameter: %s) for clientID: %d\n", tel, grcftwc.ClientID)
		return false, "", "", "", 0
	}
	// check barred telephone prefixes
	if barred.CheckBarred(telephone, Bars) {
		log.Printf("telephone number is barred (sent telephone parameter: %s) for clientID: %d\n", tel, grcftwc.ClientID)
		return false, "", "", "", 0
	}
	// Some SIMs are configured not to send international numbers and when the telephone is
	// configured to E.164 format with the local country code this is determined to be international
	// so the SMS is not sent.
	// Therefore have to replace the country code to make it a national number this is normally with a 0.
	telephoneSendSMS := telephone
	if grcftwc.ReplaceTelephoneCountryCode {
		countryForTelephone := phonenumber.GetISO3166ByNumber(telephone, true)
		// log.Println(countryForTelephone.CountryCode)
		telephoneSendSMS = strings.Replace(telephone, countryForTelephone.CountryCode, grcftwc.ReplaceTelephoneCountryCodeWith, 1)
	}

	// booking source mobile app state (BookingSourceMobileAppState)
	// this is set in the database as either:
	// -1 - ignore
	// 0 - NOT mobile app
	// 1 - mobile app
	if grcftwc.BookingSourceMobileAppState == 0 && strings.EqualFold(archiveBooking.BookingSource, autocab_api.BookingSourceMobileApp) {
		// log.Printf("booking is source mobile app but configuration is for NOT mobile app bookings for telephone: %s\n", telephone)
		return false, "", "", "", 0
	}
	if grcftwc.BookingSourceMobileAppState == 1 && !strings.EqualFold(archiveBooking.BookingSource, autocab_api.BookingSourceMobileApp) {
		// log.Printf("booking is NOT source mobile app but configuration is for mobile app bookings for telephone: %s\n", telephone)
		return false, "", "", "", 0
	}

	// companies config is set to a list of acceptable company ID's
	comps := strings.Trim(grcftwc.Companies, " ")
	companies := strings.Split(comps, ",")
	foundCompany := false
	// this is used to facilitate for none of the configured companies being an integer (also the case where nothing is configured)
	companyFailsAllAtoi := true
	for _, company := range companies {
		c, err := strconv.Atoi(strings.Trim(company, " "))
		if err != nil {
			log.Printf("Error converting company %s to an integer (in configured companies: %s) err: %+v\n", company, comps, err)
			continue
		}
		companyFailsAllAtoi = false
		if c == archiveBooking.Company.ID {
			foundCompany = true
			break
		}
	}
	if !foundCompany && !companyFailsAllAtoi {
		// log.Printf("Company %s NOT found for telephone: %s\n", telephone)
		return false, "", "", "", 0
	}

	lastSent, sentCount, stop, found := database.LastSentFromTelephoneAndClient(telephone, grcftwc.ClientID)
	// check if stop set (do not send)
	if stop {
		// log.Printf("stop on telephone: %s\n", telephone)
		return false, "", "", "", 0
	}
	// check found record
	if found {
		// check last sent greater than min send frequency
		if lastSent.After(time.Now().AddDate(0, 0, int(-grcftwc.MinSendFrequency))) {
			// log.Printf("Last sent too recent for telephone: %s\n", telephone)
			return false, "", "", "", 0
		}
		// check sent count
		if int(sentCount) > int(grcftwc.MaxSendCount) {
			// log.Printf("Reached maximum number of sends for telephone: %s\n", telephone)
			return false, "", "", "", 0
		}
	}

	// get initial message (will use database message always)
	message := grcftwc.Message
	// check for multi message
	if grcftwc.MultiMessageEnabled == 1 {
		// split message by the separator
		if message == "" {
			log.Printf("no message found for clientID: %d\n", grcftwc.ClientID)
			message = ""
		}
		sep := ""
		if message != "" {
			sep = strings.Trim(grcftwc.MultiMessageSeparator, " ")
			if sep == "" {
				log.Printf("no separator specified for multi message for clientID: %d\n", grcftwc.ClientID)
				message = ""
				sep = ""
			}
		}
		if message != "" && sep != "" {
			ms := strings.Split(message, sep)
			r := rand.Intn(len(ms))
			message = ms[r]
		}
		if message == "" {
			log.Printf("no message found for multi message after randomising found message array for clientID: %d\n", grcftwc.ClientID)
			message = ""
		}
	}
	if message == "" {
		return false, "", "", "", 0
	}

	// see whether should do dispatcher checks
	bookingCheck := true
	if grcftwc.DispatcherChecksEnabled {
		// determine whether booking is prebooked using a time difference between created and pickup time
		createdDate := archiveBooking.BookedAtTime
		pickupDate := archiveBooking.PickupDueTime
		// arriveDate := archiveBooking.VehicleArrivedAtTime
		contactDate := archiveBooking.PickedUpAtTime
		bookingForNow := utils.CheckDiffTimeRFC3339(createdDate, pickupDate, strconv.Itoa(int(grcftwc.IsBookingForNowDiffMinutes)))
		if bookingForNow {
			bookingCheck = utils.CheckDiffTimeRFC3339(pickupDate, contactDate, strconv.Itoa(int(grcftwc.BookingNowPickupToContactMinutes)))
		} else {
			bookingCheck = utils.CheckDiffTimeRFC3339(pickupDate, contactDate, strconv.Itoa(int(grcftwc.PreBookingPickupToContactMinutes)))
		}
	}

	return bookingCheck, telephone, telephoneSendSMS, message, sentCount
}

// SendReviewMasterSMSGateway - send via review master SMS gateway
// return a string representing the response from the request
func SendReviewMasterSMSGateway(telephone string, message string, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) string {
	// send to Review Master SMS Gateway
	reviewMasterSMSGatewayQueueID := grcftwc.ClientID
	if grcftwc.ReviewMasterSMSGatewayUseMasterQueue {
		reviewMasterSMSGatewayQueueID = uint64(database.ReviewMasterSMSMasterQueue)
	}
	jsonBody, _ := json.Marshal(map[string]string{
		"queue_id":  strconv.FormatUint(reviewMasterSMSGatewayQueueID, 10),
		"telephone": "+" + telephone,
		"message":   message,
	})
	headers := map[string]string{
		"Content-Type": "application/json",
		"Accept":       "application/json",
		"Api-Token":    config.Conf.ReviewMasterSMSGatewayApiToken,
	}
	resp := client.Send(config.Conf.ReviewMasterSMSGatewayURL, "POST", headers, nil, jsonBody)

	// check response to make sure it has been sent successfully:
	// example possible responses:
	// 		{"id":76} - success with message id
	// 		{"error":"unauthorized"} - unsuccessful unauthorized
	// 		{"errors":{"message":["can't be blank"]}} - unsuccessful errors
	// 		{"errors":{"telephone":["can't be blank"]}} - unsuccessful errors
	// 		{"errors":{"detail":"Bad Request"}} - unsuccessful errors
	var rJson map[string]interface{}
	if errJson := json.Unmarshal([]byte(resp), &rJson); errJson != nil {
		log.Printf("Error unmarshalling JSON from sending message from Review Master SMS Gateway APP to: %s, sending message: %s for client ID: %d to telephone: %s, response from send server: %+v, error: %+v", config.Conf.ReviewMasterSMSGatewayURL, message, grcftwc.ClientID, telephone, resp, errJson)
	}
	if _, ok := rJson["id"]; !ok {
		log.Printf("Error sending message: %s for clientID: %d to %s with params: %+v, response from send server: %+v", message, grcftwc.ClientID, config.Conf.ReviewMasterSMSGatewayURL, telephone, resp)
	} else {
		// set response to expected configured response which can be anything
		resp = grcftwc.SendSuccessResponse
	}

	return resp
}

// // SendSMSServer - send via own SMS server
// // return a string representing the response from the request
// func SendSMSServer(telephone string, message string, config config.Config, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) string {
// 	// send SMS to own server
// 	params := url.Values{}
// 	params.Add(config.SendSmsTokenParameter, config.SendSmsToken)
// 	params.Add(config.SendSmsTelephoneParameter, telephone)
// 	params.Add(config.SendSmsMessageParameter, message)
// 	resp := client.Send(config.SendSmsURL, "POST", nil, params, nil)
// 	return resp
// }

// SendSMSServer - send via own SMS server
// return a string representing the response from the request
// NOTE: This uses the send SMS mutex to prevent sending too many requests to the SMS gateway which caused it to drop requests.
func SendSMSServer(telephone string, message string, grcftwc database.GoogleReviewsConfigFromTokenWithChecks) string {
	// send SMS to own server
	params := url.Values{}
	params.Add(config.Conf.SendSmsTokenParameter, config.Conf.SendSmsToken)
	params.Add(config.Conf.SendSmsTelephoneParameter, telephone)
	params.Add(config.Conf.SendSmsMessageParameter, message)
	sendSmsMutex.Lock()
	resp := client.Send(config.Conf.SendSmsURL, "POST", nil, params, nil)
	sendSmsMutex.Unlock()
	return resp
}
